/*The follow code is generated by LALRParserGenerator written by LiBo.
 *Please don't modified the code.
 *If you want to modify the code, please modify the yacc file.
 */
#include <stdio.h>
#include <stdlib.h>

%token_definition

%declaration_code

%union_definition

%table_definition

%stack_size

%yyaux

enum yy_parser_running_status
{
	take_a_loop,
	reduce_a_sym,
	push_to_stack
	
};

struct yy_stack_elem
{
	YYSTYPE val;
	int state;
};

enum 
{
	ActSz = sizeof yyact / sizeof yyact[0],
};

struct yy_parser_context
{
	struct yy_stack_elem stk[StackSize], *ps;
	int r, n, s, tk;
	YYSTYPE yyval;
	enum yy_parser_running_status status;
};

void* yy_parser_alloc()
{
	struct yy_parser_context* ctx = (struct yy_parser_context*)malloc(sizeof(*ctx));
	if (ctx)
	{
		ctx->ps = ctx->stk;
		ctx->ps->state = ctx->s = yyini;
		ctx->tk = -1;
		ctx->status = take_a_loop;
	}
	return ctx;
}

int yy_step_parse(void* parser_ctx, int tok_type, YYSTYPE val %parser_params(", "))
{
	struct yy_parser_context* ctx = (struct yy_parser_context*)parser_ctx;
	int h;
	int want_a_tok = 0;
	do
	{
		switch(ctx->status)
		{
			case take_a_loop:
				ctx->n = yyadsp[ctx->s];
				if (ctx->tk < 0 && ctx->n > -yyntoks)
				{
					if (want_a_tok)
					{
						return 1;
					}
					ctx->tk = yytrns[tok_type];
					want_a_tok = 1;
				}
				ctx->n += ctx->tk;
				if (ctx->n < 0 || ctx->n >= ActSz || yychk[ctx->n] != ctx->tk) {
					ctx->r = yyadef[ctx->s];
					if (ctx->r < 0) {
						yyerror("syntax error");
						return -1;
					}
					ctx->status = reduce_a_sym;
					continue;
				}
				ctx->n = yyact[ctx->n];
				if (ctx->n == -1)
					return -1;
				if (ctx->n < 0) {
					ctx->r = - (ctx->n+2);
					ctx->status = reduce_a_sym;
					continue;
				}
				ctx->tk = -1;
				ctx->yyval = val;
				ctx->status = push_to_stack;
				break;
		case push_to_stack:
			ctx->ps++;
			if (ctx->ps-ctx->stk >= StackSize)
				return -2;
			ctx->s = ctx->n;
			ctx->ps->state = ctx->s;
			ctx->ps->val = ctx->yyval;
			ctx->status = take_a_loop;
			break;
		case reduce_a_sym:
			ctx->ps -= yyr1[ctx->r];
			h = yyr2[ctx->r];
			ctx->s = ctx->ps->state;
			ctx->n = yygdsp[h] + ctx->s;
			if (ctx->n < 0 || ctx->n >= ActSz || yychk[ctx->n] != yyntoks+h)
				ctx->n = yygdef[h];
			else
				ctx->n = yyact[ctx->n];
			switch (ctx->r) {
			case 0:
			ctx->yyval = ctx->ps[1].val; return 0;
			break;
%rule_reduce("ctx->")
			}
			ctx->status = push_to_stack;
		}
	}
	while (1);
}
void yy_parser_free(void *ctx)
{
	free(ctx);
}
/* The following definition will be modified,
   which is not reentrant.
*/

//Lexical interface variable
/*
reentrant mode:
%scanner_param {void* scanner}
int yylex_reentrant(void *scanner, YYSTYPE* val)

non-reentrant mode:
YYSTYPE yylval;
*/

%scanner_outer_interface_variable_definition

int yyparse(%parser_params(""))
{
	enum
	{
		ActSz = sizeof yyact / sizeof yyact[0],
	};
	struct yy_stack_elem stk[StackSize], *ps;
	int r, h, n, s, tk;
	YYSTYPE yyval;
	%scanner_inner_interface_variable_definition //YYSTYPE yyvlal;
	
	ps = stk;
	ps->state = s = yyini;
	tk = -1;
	enum yy_parser_running_status status = take_a_loop;
	do
	{
		switch(status)
		{
			case take_a_loop:
				n = yyadsp[s];
				if (tk < 0 && n > -yyntoks)
				{
					/*tk = yytrns[yylex_reentrant(scanner, &yylval)]; or
					  tk = yytrns[yylex()];
					*/
					%scanner_call_statement 					
				}
				n += tk;
				if (n < 0 || n >= ActSz || yychk[n] != tk) {
					r = yyadef[s];
					if (r < 0) {
						yyerror("syntax error");
						return -1;
					}
					status = reduce_a_sym;
					continue;
				}
				n = yyact[n];
				if (n == -1)
					return -1;
				if (n < 0) {
					r = - (n+2);
					status = reduce_a_sym;
					continue;
				}
				tk = -1;
				yyval = yylval;
				status = push_to_stack;
				break;
		case push_to_stack:
			ps++;
			if (ps-stk >= StackSize)
				return -2;
			s = n;
			ps->state = s;
			ps->val = yyval;
			status = take_a_loop;
			break;
		case reduce_a_sym:
			ps -= yyr1[r];
			h = yyr2[r];
			s = ps->state;
			n = yygdsp[h] + s;
			if (n < 0 || n >= ActSz || yychk[n] != yyntoks+h)
				n = yygdef[h];
			else
				n = yyact[n];
			switch (r) {
			case 0:
			yyval = ps[1].val; return 0;
			break;
%rule_reduce("")
			}
			status = push_to_stack;
		}
	}
	while (1);
}

%tail_code